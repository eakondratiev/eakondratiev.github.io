<!doctype html>
<html>
<head>
  <meta charset="UTF-8">
  <title>IP Range Calculator</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <meta name="apple-mobile-web-app-title" content="EA Speed &amp; Distance" />
  <meta name="application-name" content="EA Speed &amp; Distance" />
  <meta name="msapplication-config" content="/assets/icons/browserconfig.xml" />
  <meta name="theme-color" content="#ffffff" />
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/icons/apple-touch-icon-180.png" />
  <link rel="manifest" href="/assets/icons/manifest.json" />
  <link rel="icon" type="image/png" href="/assets/icons/favicon-32.png" sizes="32x32" />
  <link rel="icon" type="image/png" href="/assets/icons/favicon-16.png" sizes="16x16" />
  <link href="/assets/main.css?201912" rel="stylesheet" type="text/css" />
  <style>
    input[type=text] {padding: 2pt; width: 195px;}
    .range-calc {border-bottom: dotted 1pt #777; margin: 8pt 0; padding: 4pt 0;}
    .range-result {margin: 8pt 0;}
    .extended-range-note {color: #c00;}
  </style>
</head>
<body>
  <div class="main-content">
    <div class="page-wide header">
      <header class="content">
        <a class="site-logo" href="/">TOOL</a>
      </header>
    </div>
    <div class="page-wide">
      <div class="content">
        <h1>IP Range Calculator</h1>

        <div class="range-calc">
          <div style="margin: 4pt 0;">IP <u>R</u>ange</div>
          <input type="text" placeholder="192.168.0.0-192.168.0.255" class="form-range" accesskey="R" />
          <button onclick="CalculateRanges()" accesskey="M">Get <u>M</u>ask</button>
          <div class="range-result"></div>
        </div>
        <!-- version 2019-09-07 -->

      </div>
    </div>
  </div>
  <div class="page-wide footer">
    Web tools.
  </div>

  <script src="/assets/iplib.js"></script>
  <script>

    (function () {

      console.log('IPlib Tests');
      var normalRange = [
        IPlib.getIp4ByteArray('192.168.0.0'),
        IPlib.getIp4ByteArray('192.168.0.255')];
      var normalMask = IPlib.getMask(normalRange[0], normalRange[1]);

      var complexRange = [
        IPlib.getIp4ByteArray('221.0.0.0'),
        IPlib.getIp4ByteArray('221.3.127.255')];
      var complexMask = IPlib.getMask(complexRange[0], complexRange[1]);

      var wrongIp = IPlib.getIp4ByteArray('10.0.0.300');

      console.log('getRanges expected null',
        IPlib.getRanges(normalRange[0], wrongIp));

      console.log('getRanges expected null',
        IPlib.getRanges(normalRange[1], normalRange [0]));

      console.log('getRanges normal (one) range',
        IPlib.getRanges(normalRange[0], normalRange [1]));

      console.log('getRanges complex range, three ranges',
        IPlib.getRanges(complexRange[0], complexRange [1]));

      console.log('Constants',
        IPlib.ERR_MASK_OK,
        IPlib.ERR_MASK_WRONG,
        IPlib.ERR_MASK_COMPLEX);

      console.log('getIp4ByteArray Ok', normalRange[0]);
      console.log('getIp4ByteArray Wrong', wrongIp);

      console.log('getMask Ok',
        normalRange[0], normalRange[1], normalMask);

      console.log('getMask Wrong',
        IPlib.getMask(normalRange[0], wrongIp));

      console.log('getPrefixBitsNumber normal, expected bits:24, error:0',
        IPlib.getPrefixBitsNumber(normalMask));

      console.log('getPrefixBitsNumber null, expected bits:-1, error:1',
        IPlib.getPrefixBitsNumber(null));

      console.log('getPrefixBitsNumber complex mask, expected bits:15, error:2',
        IPlib.getPrefixBitsNumber(complexMask));

      console.log('compareIpAddresses ip1 < ip2',
        IPlib.compareIpAddresses(normalRange[0], normalRange[1]));

      console.log('compareIpAddresses ip1 = ip2',
        IPlib.compareIpAddresses(normalRange[0], normalRange[0]));

      console.log('compareIpAddresses ip1 > ip2',
        IPlib.compareIpAddresses(normalRange[1], normalRange[0]));

      console.log('compareIpAddresses NaN',
        IPlib.compareIpAddresses(normalRange[1], null));

      console.log('getMaskFromPrefixBits expected 255.0.0.0',
        IPlib.getMaskFromPrefixBits(8));

      console.log('getMaskFromPrefixBits expected 255.255.192.0',
        IPlib.getMaskFromPrefixBits(18));

      console.log('getMaskFromPrefixBits expected 0.0.0.0',
        IPlib.getMaskFromPrefixBits(33));

      console.log('getNextIp expected 192.168.0.1',
        getNextIp(normalRange[0]));

      console.log('getNextIp expected 192.168.1.0',
        getNextIp(normalRange[1]));

      console.log('getNextIp expected null',
        getNextIp(wrongIp));

      /* validation */
      console.log('isIPv4, expected true',
        IPlib.isIPv4([192, 168, 0, 0]));

      console.log('isIPv4, expected false',
        IPlib.isIPv4([192, 168, 0, 0, 0]));

      console.log('isIPv4, expected false',
        IPlib.isIPv4([192, 168, 0, 256]));

      console.log('isIPv4, expected false',
        IPlib.isIPv4(null));

      console.log('isIPv6, expected true',
        IPlib.isIPv6([0x2001, 0x0DB8, 0x0000, 0x0000, 0x0000, 0xFF00, 0x0042, 0x8329]));

      console.log('isIPv6, expected false',
        IPlib.isIPv6([0x2001, 0x0DB8, 0x0000, 0x0000, 0x0000, 0xFF00, 0x0042, 80000]));

    })();

    var ERR_MASK_OK = 0,
      ERR_MASK_WRONG = 1,
      ERR_MASK_COMPLEX = 2;
    /*
     * The complex range example:
     *   221.0.0.0 - 221.3.127.255
     *   result
     *   221.0.0.0/15 221.0.0.0 - 221.1.255.255
     *   221.2.0.0/16 221.2.0.0 - 221.2.255.255
     *   221.3.0.0/17 221.3.0.0 - 221.3.127.255
     *
     * Normal range example:
     * 192.168.0.0
     *   CIDR 192.168.0.0/24
     *   MASK: 255.255.255.0
     *   Total host: 256
     */

    document.getElementsByClassName('form-range')[0].addEventListener('keyup', function (event) {
      // Number 13 is the "Enter" key on the keyboard
      if (event.keyCode === 13) {
        // Cancel the default action, if needed
        event.preventDefault();
        // Trigger the button element with a click
        CalculateRanges();
      }
    });

    /**
      * Calculates the IP mask, CIDR and amount of IP addresses by the IP addresses range.
      */
    function CalculateRanges() {

      'use strict';

      var textElement = document.getElementsByClassName('form-range')[0],
        resultElement = document.getElementsByClassName('range-result')[0],
        text = textElement.value.trim(),
        reRange = /^([\.0-9]{7,15})\s*-\s*([\.0-9]{7,15})$/,
        m = reRange.exec(text),
        ip1,
        ip2,
        ip1PrecedesIp2,
        mask,
        cidrData;

      textElement.focus(); // otherwise the button will be emphasized

      if (m === null) {
        showError('Not IP range', resultElement);
        return;
      }

      // Get and validate IP addresses.
      // IP address arrays:
      // * four numbers (octets),
      // * element 0 - most significant, 3 - least significant.
      // For example, 192.168.0.15 indices are:
      //                0   1 2  3
      ip1 = getByteArray(m[1]); // array of four octets
      ip2 = getByteArray(m[2]);
      ip1PrecedesIp2 = (compareIpAddresses(ip1, ip2) <= 0); // false - ip2 precedes ip1, not expected.

      if (isNaN(ip1PrecedesIp2) || !ip1PrecedesIp2) {
        showError('The first IP address must precede the second IP address.', resultElement);
        return;
      }

      mask = getMask(ip1, ip2);

      if (mask === null) {
        showError('Not IP range', resultElement);
        return;
      }

      cidrData = countOnes(mask);

      if (cidrData.error === ERR_MASK_WRONG) {
        showError('Wrong range', resultElement);
        return;
      }

      var maskNote = '';

      if (cidrData.error === ERR_MASK_COMPLEX) {

        // Get real mask from CIDR
        mask = cidrToMask(cidrData.cidr);

        // Get last IP address by the mask.
        // Use same XOR: lastIp = firstIp XOR mask XOR 255
        var lastIp = getMask(ip1, mask);

        // Next range start = last IP + 1
        var nextIp = getNextIp(lastIp);

        // Next range CIDR = CIDR - 1

        maskNote = '<br /><span class="extended-range-note">' +
          'NOTE: the range consists of several IP spans, this mask covers the first and widest range.' +
          '</span > ';

      }

      var ip1text = ip1.join('.');
      var maskText = mask.join('.');

      resultElement.innerHTML =
        'Mask: <b>' + maskText + '</b>' +
        '<br />CIDR ' + ip1text + ' / ' + cidrData.cidr.toString() +
        '<br />Total IP: <b>' + (Math.pow(2, 32 - cidrData.cidr)).toLocaleString('en-US') + '</b>' +
        maskNote;

    }

    /**
      * Parses the string and returns the array of bytes representing the IP v4 address.
      * @returns {[Number]} array of four numbers,
      * array[0] is least significant octet, array[3] is most significatn.
      */
    function getByteArray(ip) {

      var result = [],
        reOctets = /^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/,
        m = reOctets.exec(ip);

      if (m === null) {
        return null;
      }

      for (var i = 1; i < 5; i++) {

        var octet = parseInt(m[i], 10);

        if (octet < 0 || octet > 255) {
          return null;
        }

        result.push(octet);

      }

      return result;

    }

    /**
      * Returns the array with the IP subnet mask bytes.
      */
    function getMask(ip1, ip2) {

      var mask = [],
        octet;

      if (ip1 === null || ip2 === null) {
        return null;
      }

      for (var i = 0; i < 4; i++) {

        octet = (ip1[i] ^ ip2[i]) ^ 255; // bitwise XOR
        mask.push(octet);

      }

      return mask;
    }

    /**
      * Returns the sructure with the number of ones in the mask and indicator of an error.
      * Returns .cidr = -1 if the mask array contains wrong bits (after ones only zeroes are possible).
      * @returns {*} .cidr - the number of sequential ones, .error - the error code.
      */
    function countOnes(mask) {

      var ones = 0,
        previuosBit = 255,
        bit,
        byte;

      if (mask === null) {
        return { cidr: -1, error: ERR_MASK_WRONG };
      }

      // Move from the most to the least significant bits (left to right)
      // so after ones only zeroes are possible in the mask.
      // 111...10..0000

      // four bytes: 0.1.2.3, from left to right
      for (var i = 0; i <= 3; i++) {

        byte = mask[i];

        // bits from left to right: 01234567
        for (j = 7; j >= 0; j--) {

          bit = byte & 128; // 128 = 1000 0000

          if (bit > 0) {
            ones++;
          }

          if (bit > previuosBit) {
            // 1 to 0 - ok, 0 to 1 - wrong
            return { cidr: ones, error: ERR_MASK_COMPLEX };
          }

          byte = byte << 1; // shift bits to the left
          previuosBit = bit;
        }

      }

      return { cidr: ones, error: ERR_MASK_OK };

    }

    /**
      * Shows the text in the element.
      */
    function showError(text, element) {
      if (text === undefined && text.length === 0) {
        return;
      }
      element.innerHTML = '<span style="color:#e00">' + text + '</span>';

    }

    /**
     * Compares two specified byte arrays and returns an integer that indicates their relative position in the sort order.
     * @param {[Number]} ip1 The first IP address (four bytes array) to compare.
     * @param {[Number]} ip2 The second IP address (four bytes array) to compare.
     * @returns {Number} A signed number that indicates the relationship between the two comparands.
     * Value -1 means the ip1 precedes ip2 in the sort order.
     * Value  0 means the ip1 and ip2 are equal.
     * Value  1 means the ip1 follows ip2 in the sort order.
     * Returns NaN when ip1 or ip2 are not array of four numbers.
     */
    function compareIpAddresses(ip1, ip2) {

      var ARRAY_SIZE = 4,
        i;

      // validate
      if (ip1 === null || typeof ip1 !== 'object' || ip1.length !== ARRAY_SIZE ||
        ip2 === null || typeof ip2 !== 'object' || ip2.length !== ARRAY_SIZE) {

        return NaN;
      }

      /* Start from most signifiacnt number. */
      for (i = 0; i < ARRAY_SIZE; i++) {

        if (ip1[i] < ip2[i]) { return -1; }
        if (ip1[i] > ip2[i]) { return 1; }
        // when equal compare less significant number, next loop.
      }

      // all elements are equal
      return 0;

    }

    /**
     * Returns array of four numbers (octets).
     * @param cidr The CIDR, the number of ones in the mask.
     */
    function cidrToMask(cidr) {

      var byte,
        bit,
        mask,
        bits = 0,
        result = [0, 0, 0, 0];

      if (cidr <= 0 || cidr > 32) {
        return result;
      }

      for (byte = 0; byte < result.length; byte++) {

        result[byte] = 0;
        mask = 128; // 128 = 1000 0000

        for (bit = 7; bit >= 0; bit--) {

          if (bits >= cidr) {
            return result;
          }

          result[byte] |= mask; // byte = byte OR mask
          mask = mask >> 1; // mask for the next bit to the right
          ++bits;

        }
      }

      return result;
    }

    /**
     * Returns the next IP after the specified IP.
     * Returns null if the specified IP address is wrong or 255.255.255.255.
     * @param ip The four numbers array, IP octets.
     * @returns Four octets array.
     */
    function getNextIp(ip) {

      var MAX_VALUE = 255,
        ADDITION = 1, /* from 0 to 255 */
        i,
        reminder = ADDITION,
        newOctetValue,
        newIp = [0, 0, 0, 0];

      if (ip === null ||
        ip.length !== 4) {

        return null;
      }

      /* from least significant to most significant octet. */
      for (i = ip.length - 1; i >= 0; i--) {

        newOctetValue = ip[i] + reminder;

        if (newOctetValue > MAX_VALUE) {
          // overflow

          if (i === 0) {
            // overflow in most significant octet
            return null;
          }

          reminder = newOctetValue % MAX_VALUE;
          newOctetValue = 0;

        }
        else {
          reminder = 0;
        }

        newIp[i] = newOctetValue;

      }

      return newIp;

    }

  </script>
</body>
</html>